% Frequency error estimation and correction
function [out_signal, freq_est] = rx_frequency_sync(rxsignal, sim_options)

global sim_consts;

[n_tx_antennas, n_rx_antennas] = get_n_antennas(sim_options);

% Estimate the frequency error
if sim_options.FreqSync
   
   % allows for error in packet detection
   pkt_det_offset = 30;
   
   % averaging length
   rlen = 128;
   
   % short training symbol periodicity
   D = 16;
   
   phase = rxsignal(:,pkt_det_offset:pkt_det_offset+rlen-D).* ...
      conj(rxsignal(:,pkt_det_offset+D:pkt_det_offset+rlen));
   
   % add all estimates 
   phase = sum(phase, 2);
   
   % with rx diversity combine antennas
   phase = sum(phase, 1);
   
   freq_est = -angle(phase) / (2*D*pi/sim_consts.SampFreq);
   
   radians_per_sample = 2*pi*freq_est/sim_consts.SampFreq;

   %% matlab function 
   freq_est_matlab = wlanCoarseCFOEstimate(rxsignal(2:161).','CBW20');  % if no packet offset

   %% user defined interval (last 5 symbols)
   phase1 = rxsignal(:,65:145).*conj(rxsignal(:,81:161));
   phase1 = sum(phase1, 2);
   freq_est_user = -angle(phase1) / (2*D*pi/sim_consts.SampFreq);
    
    %% int 
    
    %debug
    phase_d = rxsignal(:,65:145).*conj(rxsignal(:,81:161));
    phase_d = phase_d.' .* 2^22;

    %translate to int
    rxsignal_preamb = rxsignal(2:161); 
    rxsignal_int = int16(round(rxsignal_preamb .* 2^11).');
    rxsignal_int_conj_q = -imag(rxsignal_int(80:160));
    rxsignal_int_conj_i = real(rxsignal_int(80:160));

    rxsignal_int_rt = rxsignal_int(64:144);

    phase_detect_i = int32(real(rxsignal_int_rt)) .* int32(rxsignal_int_conj_i) - int32(imag(rxsignal_int_rt)) .* int32(rxsignal_int_conj_q);
    phase_detect_q = int32(rxsignal_int_conj_i) .* int32(imag(rxsignal_int_rt)) + int32(real(rxsignal_int_rt)) .* int32(rxsignal_int_conj_q);

%     phase_detect_complex = complex(phase_detect_i,phase_detect_q);
%     phase_detect_sum = sum(phase_detect_complex,1);
    
    sum_i = 0;
    sum_q = 0;
    for i = 1:length(rxsignal_int_rt)
        sum_i = sum_i + phase_detect_i(i);
        sum_q = sum_q + phase_detect_q(i);
    end

    ang = cordicatan2(sum_q,sum_i);
    denominator = (2*D*pi/sim_consts.SampFreq);
    freq_est_int = -ang / denominator;
%     freq_est_int = -ang * 200000;
%     radians_per_sample_int = 2*pi*freq_est_int/sim_consts.SampFreq;

    samples = (1:length(rxsignal));

    correction_signal_int = cos()


else
   % Magic number
   freq_est = sim_options.FreqError;
   radians_per_sample = 2*pi*freq_est/sim_consts.SampFreq;
end

% Now create a signal that has the frequency offset in the other direction
siglen=length(rxsignal(1,:));
time_base=0:siglen-1;
correction_signal=repmat(exp(-j*(radians_per_sample)*time_base),n_rx_antennas,1);

% And finally apply correction on the signal

out_signal = rxsignal.*correction_signal;

